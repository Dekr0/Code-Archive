\documentclass[landscape]{article}

\usepackage[margin=0.25in,top=6pt,headheight=-3pt,includehead]{geometry}
\usepackage{pdflscape}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{minted}
\usepackage{multicol}
\usepackage[dvipsnames]{xcolor}
\usepackage{titlesec}
\usepackage{fancyhdr}

\pagestyle{fancy}
\rhead{\thepage}
\lhead{University of Alberta}

\titleformat{\section}
{\normalfont\large\bfseries}{\thesection}{1em}{}[{\titlerule[0.5pt]\vspace{0.1em}\titlerule[0.5pt]}]
\titleformat*{\subsection}{\bfseries}

% code formatting options
\newmintedfile[cppcode]{cpp}{
    autogobble,
    breaklines,
    frame=bottomline,
    breakbytokenanywhere,
    tabsize=2
}
\newmintedfile[javacode]{java}{
    autogobble,
    breaklines,
    frame=bottomline,
    breakbytokenanywhere,
    tabsize=2
}
\newmintedfile[plaintext]{text}{
    autogobble,
    breaklines,
    frame=bottomline,
    breakbytokenanywhere,
    tabsize=2
}

% column seperator options
\setlength{\columnseprule}{2pt}
\def\columnseprulecolor{\color{OliveGreen}}

% a little helper for including snippets
\newcommand{\codesnippet}[2]{
    \subsection{#1}
    \cppcode{#2}
    \vspace{-2em}
}
\newcommand{\javacodesnippet}[2]{
    \subsection{#1}
    \javacode{#2}
    \vspace{-2em}
}
\newcommand{\plaintextsnippet}[2]{
    \subsection{#1}
    \plaintext{#2}
    \vspace{-2em}
}

\begin{document}
\begin{multicols*}{2}
\raggedcolumns

% IMO the TOC is a waste of space and would be better filled with code
\tableofcontents

% -----------------------------------------------------------------------------
% document begins here

\section{Geometry - 2D Primitives}
\codesnippet
    {Basics}
    {code/Geometry - 2D Primitives/Basics.cpp}
\codesnippet
    {Area of intersection of two circles}
    {code/Geometry - 2D Primitives/Area of intersection of two circles.cpp}
\codesnippet
    {Points of intersection of two circles}
    {code/Geometry - 2D Primitives/Points of intersection of two circles.cpp}
\codesnippet
    {Line-circle intersection}
    {code/Geometry - 2D Primitives/Line-circle intersection.cpp}
\codesnippet
    {Line-line intersection}
    {code/Geometry - 2D Primitives/Line-line intersection.cpp}
\codesnippet
    {Segment-segment intersection}
    {code/Geometry - 2D Primitives/Segment-segment intersection.cpp}
\codesnippet
    {Parabola-line intersection}
    {code/Geometry - 2D Primitives/Parabola-line intersection.cpp}
\codesnippet
    {Circle described by 3 points}
    {code/Geometry - 2D Primitives/Circle described by three points.cpp}
\codesnippet
    {Circle described by 3 lines}
    {code/Geometry - 2D Primitives/Circle described by three lines.cpp}
\codesnippet
    {Circle described by 2 points and 1 line}
    {code/Geometry - 2D Primitives/Circle described by two points and one line.cpp}
\codesnippet
    {Circle described by 2 lines and 1 point}
    {code/Geometry - 2D Primitives/Circle described by two lines and one point.cpp}

\section{Geometry - 2D Misc}
\codesnippet
    {Heron's formula for triangle area}
    {code/Geometry - 2D Misc/Heron's formula for triangle area.cpp}
\codesnippet
    {Rectangle in rectangle test}
    {code/Geometry - 2D Misc/Rectangle in rectangle test.cpp}
\codesnippet
    {Centroid and area of a simple polygon $O(N)$}
    {code/Geometry - 2D Misc/Centroid and area of a simple polygon.cpp}
\codesnippet
    {Point in polygon $O(N)$}
    {code/Geometry - 2D Misc/Point in polygon.cpp}
\codesnippet
    {Convex-hull $O(N \log N)$}
    {code/Geometry - 2D Misc/Convex-hull.cpp}

\section{Geometry - 3D}
\codesnippet
    {Primitives}
    {code/Geometry - 3D/Primitives.cpp}
\codesnippet
    {3D Convex-hull $O(N^2)$}
    {code/Geometry - 3D/Convex-hull 3D.cpp}

\section{Combinatorics}
\codesnippet
    {(Un)Ranking of K-combination out of N $O(K \log N)$}
    {code/Combinatorics/(Un)Ranking of K-combination out of N.cpp}
\codesnippet
    {(Un)Ranking of K-permutation out of N $O(K)$}
    {code/Combinatorics/(Un)Ranking of K-permutation out of N.cpp}
\codesnippet
    {Digit occurrence count $O(\log n)$}
    {code/Combinatorics/Digit occurrence count.cpp}
\codesnippet
    {Josephus Ring Survivor}
    {code/Combinatorics/Josephus Ring Survivor.cpp}

\section{Graph Theory}
\codesnippet
    {Fast flow $O(V^2E)$}
    {code/Graph Theory/Fast flow.cpp}
\codesnippet
    {Flow and negative flow}
    {code/Graph Theory/Flow and negative flow.cpp}
\codesnippet
    {Min cost max flow}
    {code/Graph Theory/Min cost max flow.cpp}
\codesnippet
    {2-Sat \& strongly connected component $O(V+E)$}
    {code/Graph Theory/2-Sat and strongly connected component.cpp}
\codesnippet
    {Bipartite matching, vertex cover, edge cover, disjoint set $O(VE)$}
    {code/Graph Theory/Bipartite matching, vertex cover, edge cover, disjoint set.cpp}
\codesnippet
    {Bipartite weighted matching $O(VE^2)$}
    {code/Graph Theory/Bipartite weighted matching.cpp}
\codesnippet
    {Cut edges and 2-edge-connected components $O(V+E)$}
    {code/Graph Theory/Cut edges and 2-edge-connected components.cpp}
\codesnippet
    {Cut vertices and 2-connected components $O(V+E)$}
    {code/Graph Theory/Cut vertices and 2-connected components.cpp}
\codesnippet
    {Dijkstra $O(E\log V)$}
    {code/Graph Theory/Dijkstra.cpp}
\codesnippet
    {Bellman ford with negative cycle detection}
    {code/Graph Theory/bellmanford_negativecycle_path.cpp}
\codesnippet
    {Minimum spanning tree}
    {code/Graph Theory/mst.cpp}

\section{Number Theory}
\codesnippet
    {Sieve of Eratosthenes $O(N \log\log N)$}
    {code/Number Theory/Sieve of Eratosthenes.cpp}
\codesnippet
    {Chinese remaindering and ext. Euclidean $O(N \log \max(M_i))$}
    {code/Number Theory/Chinese remaindering and ext. Euclidean.cpp}
\codesnippet
    {Discrete logarithm solver $O(\sqrt P)$}
    {code/Number Theory/Discrete logarithm solver.cpp}
\codesnippet
    {Euler phi $O(\sqrt n)$}
    {code/Number Theory/euler_phi.cpp}

\section{String}
\codesnippet
    {Manacher's algorithm $O(N)$}
    {code/String/Manacher's algorithm.cpp}
\codesnippet
    {KMP string matching $O(N+M)$}
    {code/String/KMP string matching.cpp}
\codesnippet
    {Suffix array $O(N log N)$}
    {code/String/Suffix array.cpp}

\section{Misc}
\codesnippet
    {FFT $O(n\log n)$}
    {code/Misc/fft.cpp}
    \bigskip\noindent
    Given a function $f: \{0,\dots,n-1\} \rightarrow C$ into the complex
    numbers, we can write the function uniquely as $f(x) = \sum_{k
    = 0}^{n-1} a_k z^k$, where $z = e^{2\pi \frac i n}$. The function fft
    takes an input function $f$ (as a vector of complex numbers),
    and returns the values $a_0,\dots,a_{n-1}$ in a vector.
    Conversely, the inversefft function takes the
    values $a_0,\dots,a_{n-1}$, and returns the function $f$.  The
    Fourier transform is useful whenever we want to compute a
    convolution, which is a function $h: \{0,\dots,n-1\} \rightarrow C$ defined
    in terms of two other functions $f$ and $g$ by $h(m) = \sum_{k =
    0}^{n-1} f(m) g(k-m)$, where the values of $m$ and $k-m$ are
    considered modulo $n$. If we write $f = \sum a_k z^k, g = \sum b_k
    z^k$, and $h = \sum c_k z^k$, then we find $c_k = a_k*z_k$, so that we
    can compute $h = inversefft(fft(f)*fft(g))$ in $O(n\log(n))$
    time, rather than the naive $O(n^2)$ time.  Complexity: $O(n
    \log(n))$, where $n$ is the size of the domain of the input
    function.  Notes: Watch out for standard floating point
    inaccuracies, etc. This code only works if your function is
    defined on a domain of length [$n$], where $n$ is a power of 2.
\codesnippet
    {Longest ascending subsequence $O(n\log n)$}
    {code/Misc/Longest ascending subsequence.cpp}
\codesnippet
    {Simplex}
    {code/Misc/Simplex.cpp}
\codesnippet
    {Segment tree $O(\log n)$}
    {code/Misc/Segment tree.cpp}
\codesnippet
    {Lazy segment tree}
    {code/Misc/lazy_segment_tree.cpp}
\codesnippet
    {Equation solving $O(NM(N+M)$}
    {code/Misc/Equation solving.cpp}
\codesnippet
    {Cubic equation solver}
    {code/Misc/Cubic equation solver.cpp}
\javacodesnippet
    {Calendar}
    {code/Misc/javaExample.java}
\codesnippet
    {Unbounded maximum stack size}
    {code/Misc/stack_size.cpp}
\codesnippet
    {C++ IO Format}
    {code/Misc/C++ IO format}
\subsection{Formulas}
Pick's Theorem: $\displaystyle A=i+\frac b 2 - 1$ ($A$:area, $i$:interior, $b$:boundary points)\\
Catalan numbers: $C_n=\displaystyle\frac 1 {n+1} {2n \choose n}=\frac{4i-2}{i+1}C_{n-1}=\sum_{i=0}^{n-1}C_iC_{n-1-i},C_0=1$\\
Triangle: $c^2=a^2+b^2-2ab\cos (\theta_c)$, $\displaystyle s=\frac 1 2(a + b + c)$, $\displaystyle inradius=\sqrt{\frac{(s-a)(s-b)(s-c)}{s}}$, $exradii_a=\displaystyle\sqrt{\frac{s(s-b)(s-c)}{s-a}}$\\
Spherical cap: $\displaystyle V=\frac{\pi h} 6 (3a^2 + h^2)$, $A=2\pi rh$ ($a$:radius of base of cap, $r$: radius of sphere, $h$: height of cap)
%TODO
\plaintextsnippet
    {Common bugs}
    {code/Misc/Common bugs}


% -----------------------------------------------------------------------------

\end{multicols*}
\end{document}
